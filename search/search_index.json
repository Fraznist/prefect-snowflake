{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-snowflake Welcome! Prefect integrations for interacting with prefect-snowflake. Getting Started Python setup Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-snowflake with pip : pip install prefect-snowflake A list of available blocks in prefect-snowflake and their setup instructions can be found here . Query from table from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow () Write pandas to table using block attributes import pandas as pd from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query from snowflake.connector.pandas_tools import write_pandas @flow def snowflake_write_pandas_flow (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) with snowflake_connector . get_connection () as conn : table_name = \"TABLE_NAME\" ddl = \"NAME STRING, NUMBER INT\" statement = f 'CREATE TABLE IF NOT EXISTS { table_name } ( { ddl } )' with conn . cursor () as cur : cur . execute ( statement ) # case sensitivity matters here! df = pd . DataFrame ([( 'Marvin' , 42 ), ( 'Ford' , 88 )], columns = [ 'NAME' , 'NUMBER' ]) success , num_chunks , num_rows , _ = write_pandas ( conn = conn , df = df , table_name = table_name , database = snowflake_connector . database , schema = snowflake_connector . schema_ # note the \"_\" suffix ) Execute get and put statements To execute get and put statements, use snowflake_query_sync . from prefect import flow from prefect_snowflake.database import SnowflakeConnector , snowflake_query_sync @flow def snowflake_put_file_to_snowflake_stage (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) snowflake_query_sync ( f \"put file:///myfolder/myfile @mystage/mystagepath\" , snowflake_connector = snowflake_connector ) Use with_options to customize options on any existing task or flow: from prefect import flow from prefect_snowflake.database import SnowflakeConnector , snowflake_query_sync custom_snowflake_query_sync = snowflake_query_sync . with_options ( name = \"My custom task name\" , retries = 2 , retry_delay_seconds = 10 , ) @flow def example_with_options_flow (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) custom_snowflake_query_sync ( f \"put file:///myfolder/myfile @mystage/mystagepath\" , snowflake_connector = snowflake_connector ) example_with_options_flow () For more tips on how to use tasks and flows in a Collection, check out Using Collections ! Blocks Catalog Below is a list of Blocks available for registration in prefect-snowflake . To register blocks in this module to view and edit them on Prefect Cloud: prefect block register -m prefect_snowflake Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI . Credentials Module SnowflakeCredentials To load the SnowflakeCredentials: from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials @flow def my_flow (): my_block = SnowflakeCredentials . load ( \"MY_BLOCK_NAME\" ) my_flow () Database Module SnowflakeConnector To load the SnowflakeConnector: from prefect import flow from prefect_snowflake.database import SnowflakeConnector @flow def my_flow (): my_block = SnowflakeConnector . load ( \"MY_BLOCK_NAME\" ) my_flow () Resources If you encounter any bugs while using prefect-snowflake , feel free to open an issue in the prefect-snowflake repository. If you have any questions or issues while using prefect-snowflake , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to star or watch prefect-snowflake for updates too! Contribute If you'd like to help contribute to fix an issue or add a feature to prefect-snowflake , please propose changes through a pull request from a fork of the repository . Contribution Steps: Fork the repository Clone the forked repository Install the repository and its dependencies: pip install -e \".[dev]\" Make desired changes. Add tests. Insert an entry to CHANGELOG.md Install pre-commit to perform quality checks prior to commit: pre-commit install git commit , git push , and create a pull request.","title":"Home"},{"location":"#prefect-snowflake","text":"","title":"prefect-snowflake"},{"location":"#welcome","text":"Prefect integrations for interacting with prefect-snowflake.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-snowflake with pip : pip install prefect-snowflake A list of available blocks in prefect-snowflake and their setup instructions can be found here .","title":"Installation"},{"location":"#query-from-table","text":"from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow ()","title":"Query from table"},{"location":"#write-pandas-to-table-using-block-attributes","text":"import pandas as pd from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query from snowflake.connector.pandas_tools import write_pandas @flow def snowflake_write_pandas_flow (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) with snowflake_connector . get_connection () as conn : table_name = \"TABLE_NAME\" ddl = \"NAME STRING, NUMBER INT\" statement = f 'CREATE TABLE IF NOT EXISTS { table_name } ( { ddl } )' with conn . cursor () as cur : cur . execute ( statement ) # case sensitivity matters here! df = pd . DataFrame ([( 'Marvin' , 42 ), ( 'Ford' , 88 )], columns = [ 'NAME' , 'NUMBER' ]) success , num_chunks , num_rows , _ = write_pandas ( conn = conn , df = df , table_name = table_name , database = snowflake_connector . database , schema = snowflake_connector . schema_ # note the \"_\" suffix )","title":"Write pandas to table using block attributes"},{"location":"#execute-get-and-put-statements","text":"To execute get and put statements, use snowflake_query_sync . from prefect import flow from prefect_snowflake.database import SnowflakeConnector , snowflake_query_sync @flow def snowflake_put_file_to_snowflake_stage (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) snowflake_query_sync ( f \"put file:///myfolder/myfile @mystage/mystagepath\" , snowflake_connector = snowflake_connector )","title":"Execute get and put statements"},{"location":"#use-with_options-to-customize-options-on-any-existing-task-or-flow","text":"from prefect import flow from prefect_snowflake.database import SnowflakeConnector , snowflake_query_sync custom_snowflake_query_sync = snowflake_query_sync . with_options ( name = \"My custom task name\" , retries = 2 , retry_delay_seconds = 10 , ) @flow def example_with_options_flow (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) custom_snowflake_query_sync ( f \"put file:///myfolder/myfile @mystage/mystagepath\" , snowflake_connector = snowflake_connector ) example_with_options_flow () For more tips on how to use tasks and flows in a Collection, check out Using Collections !","title":"Use with_options to customize options on any existing task or flow:"},{"location":"#blocks-catalog","text":"Below is a list of Blocks available for registration in prefect-snowflake . To register blocks in this module to view and edit them on Prefect Cloud: prefect block register -m prefect_snowflake Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI .","title":"Blocks Catalog"},{"location":"#credentials-module","text":"SnowflakeCredentials To load the SnowflakeCredentials: from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials @flow def my_flow (): my_block = SnowflakeCredentials . load ( \"MY_BLOCK_NAME\" ) my_flow ()","title":"Credentials Module"},{"location":"#database-module","text":"SnowflakeConnector To load the SnowflakeConnector: from prefect import flow from prefect_snowflake.database import SnowflakeConnector @flow def my_flow (): my_block = SnowflakeConnector . load ( \"MY_BLOCK_NAME\" ) my_flow ()","title":"Database Module"},{"location":"#resources","text":"If you encounter any bugs while using prefect-snowflake , feel free to open an issue in the prefect-snowflake repository. If you have any questions or issues while using prefect-snowflake , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to star or watch prefect-snowflake for updates too!","title":"Resources"},{"location":"#contribute","text":"If you'd like to help contribute to fix an issue or add a feature to prefect-snowflake , please propose changes through a pull request from a fork of the repository .","title":"Contribute"},{"location":"#contribution-steps","text":"Fork the repository Clone the forked repository Install the repository and its dependencies: pip install -e \".[dev]\" Make desired changes. Add tests. Insert an entry to CHANGELOG.md Install pre-commit to perform quality checks prior to commit: pre-commit install git commit , git push , and create a pull request.","title":"Contribution Steps:"},{"location":"credentials/","text":"prefect_snowflake.credentials Credentials block for authenticating with Snowflake. Classes InvalidPemFormat ( Exception ) Invalid PEM Format Certificate Source code in prefect_snowflake/credentials.py class InvalidPemFormat ( Exception ): \"\"\"Invalid PEM Format Certificate\"\"\" SnowflakeCredentials ( CredentialsBlock ) pydantic-model Block used to manage authentication with Snowflake. Parameters: Name Type Description Default account str The snowflake account name. required user str The user name used to authenticate. required password SecretStr The password used to authenticate. required private_key SecretStr The PEM used to authenticate. required authenticator str The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to Snowflake documentation for details, and note that externalbrowser will only work in an environment where a browser is available. required token SecretStr The OAuth or JWT Token to provide when authenticator is set to OAuth. required endpoint str The Okta endpoint to use when authenticator is set to okta_endpoint , e.g. https://<okta_account_name>.okta.com . required role str The name of the default role to use. required autocommit bool Whether to automatically commit. required Examples: Load stored Snowflake credentials: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) Source code in prefect_snowflake/credentials.py class SnowflakeCredentials ( CredentialsBlock ): \"\"\" Block used to manage authentication with Snowflake. Args: account (str): The snowflake account name. user (str): The user name used to authenticate. password (SecretStr): The password used to authenticate. private_key (SecretStr): The PEM used to authenticate. authenticator (str): The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to [Snowflake documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect) for details, and note that `externalbrowser` will only work in an environment where a browser is available. token (SecretStr): The OAuth or JWT Token to provide when authenticator is set to OAuth. endpoint (str): The Okta endpoint to use when authenticator is set to `okta_endpoint`, e.g. `https://<okta_account_name>.okta.com`. role (str): The name of the default role to use. autocommit (bool): Whether to automatically commit. Example: Load stored Snowflake credentials: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") ``` \"\"\" # noqa E501 _block_type_name = \"Snowflake Credentials\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa account : str = Field ( ... , description = \"The snowflake account name.\" , example = \"nh12345.us-east-2.aws\" ) user : str = Field ( ... , description = \"The user name used to authenticate.\" ) password : Optional [ SecretStr ] = Field ( default = None , description = \"The password used to authenticate.\" ) private_key : Optional [ SecretBytes ] = Field ( default = None , description = \"The PEM used to authenticate.\" ) authenticator : Literal [ \"snowflake\" , \"externalbrowser\" , \"okta_endpoint\" , \"oauth\" , \"username_password_mfa\" , ] = Field ( # noqa default = \"snowflake\" , description = ( \"The type of authenticator to use for initializing connection.\" ), ) token : Optional [ SecretStr ] = Field ( default = None , description = ( \"The OAuth or JWT Token to provide when authenticator is set to `oauth`.\" ), ) endpoint : Optional [ str ] = Field ( default = None , description = ( \"The Okta endpoint to use when authenticator is set to `okta_endpoint`.\" ), ) role : Optional [ str ] = Field ( default = None , description = \"The name of the default role to use.\" ) autocommit : Optional [ bool ] = Field ( default = None , description = \"Whether to automatically commit.\" ) @root_validator ( pre = True ) def _validate_auth_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" auth_params = ( \"password\" , \"private_key\" , \"authenticator\" , \"token\" ) if not any ( values . get ( param ) for param in auth_params ): auth_str = \", \" . join ( auth_params ) raise ValueError ( f \"One of the authentication keys must be provided: { auth_str } \\n \" ) return values @root_validator ( pre = True ) def _validate_token_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) token = values . get ( \"token\" ) if authenticator == \"oauth\" and not token : raise ValueError ( \"If authenticator is set to `oauth`, `token` must be provided\" ) return values @root_validator ( pre = True ) def _validate_okta_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) # did not want to make a breaking change so we will allow both # see https://github.com/PrefectHQ/prefect-snowflake/issues/44 if \"okta_endpoint\" in values . keys (): warnings . warn ( \"Please specify `endpoint` instead of `okta_endpoint`.\" , DeprecationWarning , ) # remove okta endpoint from fields okta_endpoint = values . pop ( \"okta_endpoint\" ) if \"endpoint\" not in values . keys (): values [ \"endpoint\" ] = okta_endpoint endpoint = values . get ( \"endpoint\" ) if authenticator == \"okta_endpoint\" and not endpoint : raise ValueError ( \"If authenticator is set to `okta_endpoint`, \" \"`endpoint` must be provided\" ) return values @validator ( \"private_key\" ) def _validate_private_key ( cls , private_key ): \"\"\" Ensure a private_key looks like a PEM format certificate. \"\"\" if private_key is None : return None assert isinstance ( private_key , SecretBytes ) pk = cls . _decode_secret ( private_key ) return None if pk is None else SecretBytes ( cls . _compose_pem ( pk )) def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), ) @staticmethod def _decode_secret ( secret : Union [ SecretStr , SecretBytes ]) -> Optional [ bytes ]: \"\"\" Decode the provided secret into bytes. If the secret is not a string or bytes, or it is whitespace, then return None. Args: secret: The value to decode. Returns: The decoded secret as bytes. \"\"\" if isinstance ( secret , ( SecretBytes , SecretStr )): secret = secret . get_secret_value () if not isinstance ( secret , ( bytes , str )) or len ( secret ) == 0 or secret . isspace (): return None return secret if isinstance ( secret , bytes ) else secret . encode () @staticmethod def _compose_pem ( private_key : bytes ) -> bytes : \"\"\"Validate structure of PEM certificate. The original key passed from Prefect is sometimes malformed. This function recomposes the key into a valid key that will pass the serialization step when resolving the key to a DER. Args: private_key: A valid PEM format byte encoded string. Returns: byte encoded certificate. Raises: InvalidPemFormat: if private key is an invalid format. \"\"\" pem_parts = re . match ( _SIMPLE_PEM_CERTIFICATE_REGEX , private_key . decode ()) if pem_parts is None : raise InvalidPemFormat () body = \" \\n \" . join ( re . split ( r \"\\s+\" , pem_parts [ 2 ] . strip ())) # reassemble header+body+footer return f \" { pem_parts [ 1 ] } \\n { body } \\n { pem_parts [ 3 ] } \" . encode () def get_client ( self , ** connect_kwargs : Dict [ str , Any ] ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query Snowflake databases. Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the [Snowflake Python connector documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect). Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: An authenticated Snowflake connection. Example: Get Snowflake connection with only block configuration: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client() ``` Get Snowflake connector scoped to a specified database: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client(database=\"my_database\") ``` \"\"\" # noqa connect_params = { ** connect_kwargs , # required to track task's usage in the Snowflake Partner Network Portal \"application\" : \"Prefect_Snowflake_Collection\" , ** self . dict ( exclude_unset = True , exclude = { \"block_type_slug\" }), } for key , value in connect_params . items (): if isinstance ( value , SecretField ): connect_params [ key ] = connect_params [ key ] . get_secret_value () # set authenticator to the actual okta_endpoint if connect_params . get ( \"authenticator\" ) == \"okta_endpoint\" : endpoint = connect_params . pop ( \"endpoint\" , None ) or connect_params . pop ( \"okta_endpoint\" , None ) # okta_endpoint is deprecated connect_params [ \"authenticator\" ] = endpoint private_der_key = self . resolve_private_key () if private_der_key is not None : connect_params [ \"private_key\" ] = private_der_key connect_params . pop ( \"password\" , None ) return snowflake . connector . connect ( ** connect_params ) Attributes account : str pydantic-field required The snowflake account name. authenticator : Literal [ 'snowflake' , 'externalbrowser' , 'okta_endpoint' , 'oauth' , 'username_password_mfa' ] pydantic-field The type of authenticator to use for initializing connection. autocommit : bool pydantic-field Whether to automatically commit. endpoint : str pydantic-field The Okta endpoint to use when authenticator is set to okta_endpoint . password : SecretStr pydantic-field The password used to authenticate. private_key : SecretBytes pydantic-field The PEM used to authenticate. role : str pydantic-field The name of the default role to use. token : SecretStr pydantic-field The OAuth or JWT Token to provide when authenticator is set to oauth . user : str pydantic-field required The user name used to authenticate. Methods __json_encoder__ special staticmethod partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. get_client Returns an authenticated connection that can be used to query Snowflake databases. Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the Snowflake Python connector documentation . Parameters: Name Type Description Default **connect_kwargs Dict[str, Any] Additional arguments to pass to snowflake.connector.connect . {} Returns: Type Description SnowflakeConnection An authenticated Snowflake connection. Examples: Get Snowflake connection with only block configuration: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) connection = snowflake_credentials_block . get_client () Get Snowflake connector scoped to a specified database: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) connection = snowflake_credentials_block . get_client ( database = \"my_database\" ) Source code in prefect_snowflake/credentials.py def get_client ( self , ** connect_kwargs : Dict [ str , Any ] ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query Snowflake databases. Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the [Snowflake Python connector documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect). Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: An authenticated Snowflake connection. Example: Get Snowflake connection with only block configuration: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client() ``` Get Snowflake connector scoped to a specified database: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client(database=\"my_database\") ``` \"\"\" # noqa connect_params = { ** connect_kwargs , # required to track task's usage in the Snowflake Partner Network Portal \"application\" : \"Prefect_Snowflake_Collection\" , ** self . dict ( exclude_unset = True , exclude = { \"block_type_slug\" }), } for key , value in connect_params . items (): if isinstance ( value , SecretField ): connect_params [ key ] = connect_params [ key ] . get_secret_value () # set authenticator to the actual okta_endpoint if connect_params . get ( \"authenticator\" ) == \"okta_endpoint\" : endpoint = connect_params . pop ( \"endpoint\" , None ) or connect_params . pop ( \"okta_endpoint\" , None ) # okta_endpoint is deprecated connect_params [ \"authenticator\" ] = endpoint private_der_key = self . resolve_private_key () if private_der_key is not None : connect_params [ \"private_key\" ] = private_der_key connect_params . pop ( \"password\" , None ) return snowflake . connector . connect ( ** connect_params ) resolve_private_key Converts a PEM encoded private key into a DER binary key. Returns: Type Description Optional[bytes] DER encoded key if private_key has been provided otherwise returns None. Exceptions: Type Description InvalidPemFormat If private key is not in PEM format. Source code in prefect_snowflake/credentials.py def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), )","title":"Credentials"},{"location":"credentials/#prefect_snowflake.credentials","text":"Credentials block for authenticating with Snowflake.","title":"credentials"},{"location":"credentials/#prefect_snowflake.credentials-classes","text":"","title":"Classes"},{"location":"credentials/#prefect_snowflake.credentials.InvalidPemFormat","text":"Invalid PEM Format Certificate Source code in prefect_snowflake/credentials.py class InvalidPemFormat ( Exception ): \"\"\"Invalid PEM Format Certificate\"\"\"","title":"InvalidPemFormat"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials","text":"Block used to manage authentication with Snowflake. Parameters: Name Type Description Default account str The snowflake account name. required user str The user name used to authenticate. required password SecretStr The password used to authenticate. required private_key SecretStr The PEM used to authenticate. required authenticator str The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to Snowflake documentation for details, and note that externalbrowser will only work in an environment where a browser is available. required token SecretStr The OAuth or JWT Token to provide when authenticator is set to OAuth. required endpoint str The Okta endpoint to use when authenticator is set to okta_endpoint , e.g. https://<okta_account_name>.okta.com . required role str The name of the default role to use. required autocommit bool Whether to automatically commit. required Examples: Load stored Snowflake credentials: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) Source code in prefect_snowflake/credentials.py class SnowflakeCredentials ( CredentialsBlock ): \"\"\" Block used to manage authentication with Snowflake. Args: account (str): The snowflake account name. user (str): The user name used to authenticate. password (SecretStr): The password used to authenticate. private_key (SecretStr): The PEM used to authenticate. authenticator (str): The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to [Snowflake documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect) for details, and note that `externalbrowser` will only work in an environment where a browser is available. token (SecretStr): The OAuth or JWT Token to provide when authenticator is set to OAuth. endpoint (str): The Okta endpoint to use when authenticator is set to `okta_endpoint`, e.g. `https://<okta_account_name>.okta.com`. role (str): The name of the default role to use. autocommit (bool): Whether to automatically commit. Example: Load stored Snowflake credentials: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") ``` \"\"\" # noqa E501 _block_type_name = \"Snowflake Credentials\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa account : str = Field ( ... , description = \"The snowflake account name.\" , example = \"nh12345.us-east-2.aws\" ) user : str = Field ( ... , description = \"The user name used to authenticate.\" ) password : Optional [ SecretStr ] = Field ( default = None , description = \"The password used to authenticate.\" ) private_key : Optional [ SecretBytes ] = Field ( default = None , description = \"The PEM used to authenticate.\" ) authenticator : Literal [ \"snowflake\" , \"externalbrowser\" , \"okta_endpoint\" , \"oauth\" , \"username_password_mfa\" , ] = Field ( # noqa default = \"snowflake\" , description = ( \"The type of authenticator to use for initializing connection.\" ), ) token : Optional [ SecretStr ] = Field ( default = None , description = ( \"The OAuth or JWT Token to provide when authenticator is set to `oauth`.\" ), ) endpoint : Optional [ str ] = Field ( default = None , description = ( \"The Okta endpoint to use when authenticator is set to `okta_endpoint`.\" ), ) role : Optional [ str ] = Field ( default = None , description = \"The name of the default role to use.\" ) autocommit : Optional [ bool ] = Field ( default = None , description = \"Whether to automatically commit.\" ) @root_validator ( pre = True ) def _validate_auth_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" auth_params = ( \"password\" , \"private_key\" , \"authenticator\" , \"token\" ) if not any ( values . get ( param ) for param in auth_params ): auth_str = \", \" . join ( auth_params ) raise ValueError ( f \"One of the authentication keys must be provided: { auth_str } \\n \" ) return values @root_validator ( pre = True ) def _validate_token_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) token = values . get ( \"token\" ) if authenticator == \"oauth\" and not token : raise ValueError ( \"If authenticator is set to `oauth`, `token` must be provided\" ) return values @root_validator ( pre = True ) def _validate_okta_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) # did not want to make a breaking change so we will allow both # see https://github.com/PrefectHQ/prefect-snowflake/issues/44 if \"okta_endpoint\" in values . keys (): warnings . warn ( \"Please specify `endpoint` instead of `okta_endpoint`.\" , DeprecationWarning , ) # remove okta endpoint from fields okta_endpoint = values . pop ( \"okta_endpoint\" ) if \"endpoint\" not in values . keys (): values [ \"endpoint\" ] = okta_endpoint endpoint = values . get ( \"endpoint\" ) if authenticator == \"okta_endpoint\" and not endpoint : raise ValueError ( \"If authenticator is set to `okta_endpoint`, \" \"`endpoint` must be provided\" ) return values @validator ( \"private_key\" ) def _validate_private_key ( cls , private_key ): \"\"\" Ensure a private_key looks like a PEM format certificate. \"\"\" if private_key is None : return None assert isinstance ( private_key , SecretBytes ) pk = cls . _decode_secret ( private_key ) return None if pk is None else SecretBytes ( cls . _compose_pem ( pk )) def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), ) @staticmethod def _decode_secret ( secret : Union [ SecretStr , SecretBytes ]) -> Optional [ bytes ]: \"\"\" Decode the provided secret into bytes. If the secret is not a string or bytes, or it is whitespace, then return None. Args: secret: The value to decode. Returns: The decoded secret as bytes. \"\"\" if isinstance ( secret , ( SecretBytes , SecretStr )): secret = secret . get_secret_value () if not isinstance ( secret , ( bytes , str )) or len ( secret ) == 0 or secret . isspace (): return None return secret if isinstance ( secret , bytes ) else secret . encode () @staticmethod def _compose_pem ( private_key : bytes ) -> bytes : \"\"\"Validate structure of PEM certificate. The original key passed from Prefect is sometimes malformed. This function recomposes the key into a valid key that will pass the serialization step when resolving the key to a DER. Args: private_key: A valid PEM format byte encoded string. Returns: byte encoded certificate. Raises: InvalidPemFormat: if private key is an invalid format. \"\"\" pem_parts = re . match ( _SIMPLE_PEM_CERTIFICATE_REGEX , private_key . decode ()) if pem_parts is None : raise InvalidPemFormat () body = \" \\n \" . join ( re . split ( r \"\\s+\" , pem_parts [ 2 ] . strip ())) # reassemble header+body+footer return f \" { pem_parts [ 1 ] } \\n { body } \\n { pem_parts [ 3 ] } \" . encode () def get_client ( self , ** connect_kwargs : Dict [ str , Any ] ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query Snowflake databases. Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the [Snowflake Python connector documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect). Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: An authenticated Snowflake connection. Example: Get Snowflake connection with only block configuration: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client() ``` Get Snowflake connector scoped to a specified database: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client(database=\"my_database\") ``` \"\"\" # noqa connect_params = { ** connect_kwargs , # required to track task's usage in the Snowflake Partner Network Portal \"application\" : \"Prefect_Snowflake_Collection\" , ** self . dict ( exclude_unset = True , exclude = { \"block_type_slug\" }), } for key , value in connect_params . items (): if isinstance ( value , SecretField ): connect_params [ key ] = connect_params [ key ] . get_secret_value () # set authenticator to the actual okta_endpoint if connect_params . get ( \"authenticator\" ) == \"okta_endpoint\" : endpoint = connect_params . pop ( \"endpoint\" , None ) or connect_params . pop ( \"okta_endpoint\" , None ) # okta_endpoint is deprecated connect_params [ \"authenticator\" ] = endpoint private_der_key = self . resolve_private_key () if private_der_key is not None : connect_params [ \"private_key\" ] = private_der_key connect_params . pop ( \"password\" , None ) return snowflake . connector . connect ( ** connect_params )","title":"SnowflakeCredentials"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials-attributes","text":"","title":"Attributes"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.account","text":"The snowflake account name.","title":"account"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.authenticator","text":"The type of authenticator to use for initializing connection.","title":"authenticator"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.autocommit","text":"Whether to automatically commit.","title":"autocommit"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.endpoint","text":"The Okta endpoint to use when authenticator is set to okta_endpoint .","title":"endpoint"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.password","text":"The password used to authenticate.","title":"password"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.private_key","text":"The PEM used to authenticate.","title":"private_key"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.role","text":"The name of the default role to use.","title":"role"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.token","text":"The OAuth or JWT Token to provide when authenticator is set to oauth .","title":"token"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.user","text":"The user name used to authenticate.","title":"user"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials-methods","text":"","title":"Methods"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.get_client","text":"Returns an authenticated connection that can be used to query Snowflake databases. Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the Snowflake Python connector documentation . Parameters: Name Type Description Default **connect_kwargs Dict[str, Any] Additional arguments to pass to snowflake.connector.connect . {} Returns: Type Description SnowflakeConnection An authenticated Snowflake connection. Examples: Get Snowflake connection with only block configuration: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) connection = snowflake_credentials_block . get_client () Get Snowflake connector scoped to a specified database: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) connection = snowflake_credentials_block . get_client ( database = \"my_database\" ) Source code in prefect_snowflake/credentials.py def get_client ( self , ** connect_kwargs : Dict [ str , Any ] ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query Snowflake databases. Any additional arguments passed to this method will be used to configure the SnowflakeConnection. For available parameters, please refer to the [Snowflake Python connector documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect). Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: An authenticated Snowflake connection. Example: Get Snowflake connection with only block configuration: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client() ``` Get Snowflake connector scoped to a specified database: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") connection = snowflake_credentials_block.get_client(database=\"my_database\") ``` \"\"\" # noqa connect_params = { ** connect_kwargs , # required to track task's usage in the Snowflake Partner Network Portal \"application\" : \"Prefect_Snowflake_Collection\" , ** self . dict ( exclude_unset = True , exclude = { \"block_type_slug\" }), } for key , value in connect_params . items (): if isinstance ( value , SecretField ): connect_params [ key ] = connect_params [ key ] . get_secret_value () # set authenticator to the actual okta_endpoint if connect_params . get ( \"authenticator\" ) == \"okta_endpoint\" : endpoint = connect_params . pop ( \"endpoint\" , None ) or connect_params . pop ( \"okta_endpoint\" , None ) # okta_endpoint is deprecated connect_params [ \"authenticator\" ] = endpoint private_der_key = self . resolve_private_key () if private_der_key is not None : connect_params [ \"private_key\" ] = private_der_key connect_params . pop ( \"password\" , None ) return snowflake . connector . connect ( ** connect_params )","title":"get_client()"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.resolve_private_key","text":"Converts a PEM encoded private key into a DER binary key. Returns: Type Description Optional[bytes] DER encoded key if private_key has been provided otherwise returns None. Exceptions: Type Description InvalidPemFormat If private key is not in PEM format. Source code in prefect_snowflake/credentials.py def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), )","title":"resolve_private_key()"},{"location":"database/","text":"prefect_snowflake.database Module for querying against Snowflake databases. Classes SnowflakeConnector ( DatabaseBlock ) pydantic-model Block used to manage connections with Snowflake. Upon instantiating, a connection is created and maintained for the life of the object until the close method is called. It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited. It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor will be lost. Parameters: Name Type Description Default credentials The credentials to authenticate with Snowflake. required database The name of the default database to use. required warehouse The name of the default warehouse to use. required schema The name of the default schema to use; this attribute is accessible through SnowflakeConnector(...).schema_ . required fetch_size The number of rows to fetch at a time. required poll_frequency_s The number of seconds before checking query. required Examples: Load stored Snowflake connector as a context manager: from prefect_snowflake.database import SnowflakeConnector snowflake_connector = SnowflakeConnector . load ( \"BLOCK_NAME\" ): Insert data into database and fetch results. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) results = conn . fetch_all ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Space\" } ) print ( results ) Source code in prefect_snowflake/database.py class SnowflakeConnector ( DatabaseBlock ): \"\"\" Block used to manage connections with Snowflake. Upon instantiating, a connection is created and maintained for the life of the object until the close method is called. It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited. It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor will be lost. Args: credentials: The credentials to authenticate with Snowflake. database: The name of the default database to use. warehouse: The name of the default warehouse to use. schema: The name of the default schema to use; this attribute is accessible through `SnowflakeConnector(...).schema_`. fetch_size: The number of rows to fetch at a time. poll_frequency_s: The number of seconds before checking query. Examples: Load stored Snowflake connector as a context manager: ```python from prefect_snowflake.database import SnowflakeConnector snowflake_connector = SnowflakeConnector.load(\"BLOCK_NAME\"): ``` Insert data into database and fetch results. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) results = conn.fetch_all( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Space\"} ) print(results) ``` \"\"\" # noqa _block_type_name = \"Snowflake Connector\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa _description = \"Perform data operations against a Snowflake database.\" credentials : SnowflakeCredentials = Field ( default =... , description = \"The credentials to authenticate with Snowflake.\" ) database : str = Field ( default =... , description = \"The name of the default database to use.\" ) warehouse : str = Field ( default =... , description = \"The name of the default warehouse to use.\" ) schema_ : str = Field ( default =... , alias = \"schema\" , description = \"The name of the default schema to use.\" , ) fetch_size : int = Field ( default = 1 , description = \"The default number of rows to fetch at a time.\" ) poll_frequency_s : int = Field ( default = 1 , title = \"Poll Frequency [seconds]\" , description = ( \"The number of seconds between checking query \" \"status for long running queries.\" ), ) _connection : Optional [ SnowflakeConnection ] = None _unique_cursors : Dict [ str , SnowflakeCursor ] = None def get_connection ( self , ** connect_kwargs : Dict [ str , Any ]) -> SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) with snowflake_connector.get_connection() as connection: ... ``` \"\"\" if self . _connection is not None : return self . _connection connect_params = { \"database\" : self . database , \"warehouse\" : self . warehouse , \"schema\" : self . schema_ , } connection = self . credentials . get_client ( ** connect_kwargs , ** connect_params ) return connection def _start_connection ( self ): \"\"\" Starts Snowflake database connection. \"\"\" self . _connection = self . get_connection () def block_initialization ( self ) -> None : super () . block_initialization () if self . _connection is None : self . _start_connection () if self . _unique_cursors is None : self . _unique_cursors = {} def _get_cursor ( self , inputs : Dict [ str , Any ]) -> Tuple [ bool , SnowflakeCursor ]: \"\"\" Get a Snowflake cursor. Args: inputs: The inputs to generate a unique hash, used to decide whether a new cursor should be used. Returns: Whether a cursor is new and a Snowflake cursor. \"\"\" input_hash = hash_objects ( inputs ) if input_hash is None : raise RuntimeError ( \"We were not able to hash your inputs, \" \"which resulted in an unexpected data return; \" \"please open an issue with a reproducible example.\" ) if input_hash not in self . _unique_cursors . keys (): new_cursor = self . _connection . cursor () self . _unique_cursors [ input_hash ] = new_cursor return True , new_cursor else : existing_cursor = self . _unique_cursors [ input_hash ] return False , existing_cursor async def _execute_async ( self , cursor : SnowflakeCursor , inputs : Dict [ str , Any ]): \"\"\"Helper method to execute operations asynchronously.\"\"\" response = await run_sync_in_worker_thread ( cursor . execute_async , ** inputs ) self . logger . info ( f \"Executing the operation, { inputs [ 'command' ] !r} , asynchronously; \" f \"polling for the result every { self . poll_frequency_s } seconds.\" ) query_id = response [ \"queryId\" ] while self . _connection . is_still_running ( await run_sync_in_worker_thread ( self . _connection . get_query_status_throw_if_error , query_id ) ): await asyncio . sleep ( self . poll_frequency_s ) await run_sync_in_worker_thread ( cursor . get_results_from_sfqid , query_id ) def reset_cursors ( self ) -> None : \"\"\" Tries to close all opened cursors. Examples: Reset the cursors to refresh cursor position. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) print(conn.fetch_one(\"SELECT * FROM customers\")) # Ford conn.reset_cursors() print(conn.fetch_one(\"SELECT * FROM customers\")) # should be Ford again ``` \"\"\" # noqa input_hashes = tuple ( self . _unique_cursors . keys ()) for input_hash in input_hashes : cursor = self . _unique_cursors . pop ( input_hash ) try : cursor . close () except Exception as exc : self . logger . warning ( f \"Failed to close cursor for input hash { input_hash !r} : { exc } \" ) self . logger . info ( \"Successfully reset the cursors.\" ) @sync_compatible async def fetch_one ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> Tuple [ Any ]: \"\"\" Fetch a single result from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A tuple containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch one row from the database where address is Space. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_one( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Space\"} ) print(result) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch a row.\" ) result = await run_sync_in_worker_thread ( cursor . fetchone ) return result @sync_compatible async def fetch_many ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , size : Optional [ int ] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch a limited number of results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. size: The number of results to return; if None or 0, uses the value of `fetch_size` configured on the block. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Repeatedly fetch two rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Highway 42\"}, ], ) result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Marvin, Ford result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Unknown, Me ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) size = size or self . fetch_size self . logger . debug ( f \"Preparing to fetch { size } rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchmany , size = size ) return result @sync_compatible async def fetch_all ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch all results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch all rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_all( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, ) print(result) # Marvin, Ford, Unknown ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch all rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchall ) return result @sync_compatible async def execute ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> None : \"\"\" Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Examples: Create table named customers with two columns, name and address. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . execute , ** inputs ) self . logger . info ( f \"Executed the operation, { operation !r} .\" ) @sync_compatible async def execute_many ( self , operation : str , seq_of_parameters : List [ Dict [ str , Any ]], ) -> None : \"\"\" Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling. Args: operation: The SQL query or other operation to be executed. seq_of_parameters: The sequence of parameters for the operation. Examples: Create table and insert three rows into it. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, ], ) ``` \"\"\" # noqa inputs = dict ( command = operation , seqparams = seq_of_parameters , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . executemany , ** inputs ) self . logger . info ( f \"Executed { len ( seq_of_parameters ) } operations off { operation !r} .\" ) def close ( self ): \"\"\" Closes connection and its cursors. \"\"\" try : self . reset_cursors () finally : if self . _connection is not None : self . _connection . close () self . _connection = None self . logger . info ( \"Successfully closed the Snowflake connection.\" ) def __enter__ ( self ): \"\"\" Start a connection upon entry. \"\"\" return self def __exit__ ( self , * args ): \"\"\" Closes connection and its cursors upon exit. \"\"\" self . close () def __getstate__ ( self ): \"\"\"Allows block to be pickled and dumped.\"\"\" data = self . __dict__ . copy () data . update ({ k : None for k in { \"_connection\" , \"_unique_cursors\" }}) return data def __setstate__ ( self , data : dict ): \"\"\"Reset connection and cursors upon loading.\"\"\" self . __dict__ . update ( data ) self . _unique_cursors = {} self . _start_connection () Attributes credentials : SnowflakeCredentials pydantic-field required The credentials to authenticate with Snowflake. database : str pydantic-field required The name of the default database to use. fetch_size : int pydantic-field The default number of rows to fetch at a time. poll_frequency_s : int pydantic-field The number of seconds between checking query status for long running queries. schema_ : str pydantic-field required The name of the default schema to use. warehouse : str pydantic-field required The name of the default warehouse to use. Methods __enter__ special Start a connection upon entry. Source code in prefect_snowflake/database.py def __enter__ ( self ): \"\"\" Start a connection upon entry. \"\"\" return self __exit__ special Closes connection and its cursors upon exit. Source code in prefect_snowflake/database.py def __exit__ ( self , * args ): \"\"\" Closes connection and its cursors upon exit. \"\"\" self . close () __getstate__ special Allows block to be pickled and dumped. Source code in prefect_snowflake/database.py def __getstate__ ( self ): \"\"\"Allows block to be pickled and dumped.\"\"\" data = self . __dict__ . copy () data . update ({ k : None for k in { \"_connection\" , \"_unique_cursors\" }}) return data __json_encoder__ special staticmethod partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. __setstate__ special Reset connection and cursors upon loading. Source code in prefect_snowflake/database.py def __setstate__ ( self , data : dict ): \"\"\"Reset connection and cursors upon loading.\"\"\" self . __dict__ . update ( data ) self . _unique_cursors = {} self . _start_connection () close Closes connection and its cursors. Source code in prefect_snowflake/database.py def close ( self ): \"\"\" Closes connection and its cursors. \"\"\" try : self . reset_cursors () finally : if self . _connection is not None : self . _connection . close () self . _connection = None self . logger . info ( \"Successfully closed the Snowflake connection.\" ) execute async Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Examples: Create table named customers with two columns, name and address. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) Source code in prefect_snowflake/database.py @sync_compatible async def execute ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> None : \"\"\" Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Examples: Create table named customers with two columns, name and address. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . execute , ** inputs ) self . logger . info ( f \"Executed the operation, { operation !r} .\" ) execute_many async Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required seq_of_parameters List[Dict[str, Any]] The sequence of parameters for the operation. required Examples: Create table and insert three rows into it. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Marvin\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, ], ) Source code in prefect_snowflake/database.py @sync_compatible async def execute_many ( self , operation : str , seq_of_parameters : List [ Dict [ str , Any ]], ) -> None : \"\"\" Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling. Args: operation: The SQL query or other operation to be executed. seq_of_parameters: The sequence of parameters for the operation. Examples: Create table and insert three rows into it. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, ], ) ``` \"\"\" # noqa inputs = dict ( command = operation , seqparams = seq_of_parameters , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . executemany , ** inputs ) self . logger . info ( f \"Executed { len ( seq_of_parameters ) } operations off { operation !r} .\" ) fetch_all async Fetch all results from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Returns: Type Description List[Tuple[Any]] A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch all rows from the database where address is Highway 42. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Marvin\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) result = conn . fetch_all ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Highway 42\" }, ) print ( result ) # Marvin, Ford, Unknown Source code in prefect_snowflake/database.py @sync_compatible async def fetch_all ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch all results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch all rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_all( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, ) print(result) # Marvin, Ford, Unknown ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch all rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchall ) return result fetch_many async Fetch a limited number of results from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None size Optional[int] The number of results to return; if None or 0, uses the value of fetch_size configured on the block. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Returns: Type Description List[Tuple[Any]] A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Repeatedly fetch two rows from the database where address is Highway 42. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Marvin\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Me\" , \"address\" : \"Highway 42\" }, ], ) result = conn . fetch_many ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Highway 42\" }, size = 2 ) print ( result ) # Marvin, Ford result = conn . fetch_many ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Highway 42\" }, size = 2 ) print ( result ) # Unknown, Me Source code in prefect_snowflake/database.py @sync_compatible async def fetch_many ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , size : Optional [ int ] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch a limited number of results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. size: The number of results to return; if None or 0, uses the value of `fetch_size` configured on the block. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Repeatedly fetch two rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Highway 42\"}, ], ) result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Marvin, Ford result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Unknown, Me ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) size = size or self . fetch_size self . logger . debug ( f \"Preparing to fetch { size } rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchmany , size = size ) return result fetch_one async Fetch a single result from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Returns: Type Description Tuple[Any] A tuple containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch one row from the database where address is Space. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) result = conn . fetch_one ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Space\" } ) print ( result ) Source code in prefect_snowflake/database.py @sync_compatible async def fetch_one ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> Tuple [ Any ]: \"\"\" Fetch a single result from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A tuple containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch one row from the database where address is Space. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_one( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Space\"} ) print(result) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch a row.\" ) result = await run_sync_in_worker_thread ( cursor . fetchone ) return result get_connection Returns an authenticated connection that can be used to query from Snowflake databases. Parameters: Name Type Description Default **connect_kwargs Dict[str, Any] Additional arguments to pass to snowflake.connector.connect . {} Returns: Type Description SnowflakeConnection The authenticated SnowflakeConnection. Examples: from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) with snowflake_connector . get_connection () as connection : ... Source code in prefect_snowflake/database.py def get_connection ( self , ** connect_kwargs : Dict [ str , Any ]) -> SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) with snowflake_connector.get_connection() as connection: ... ``` \"\"\" if self . _connection is not None : return self . _connection connect_params = { \"database\" : self . database , \"warehouse\" : self . warehouse , \"schema\" : self . schema_ , } connection = self . credentials . get_client ( ** connect_kwargs , ** connect_params ) return connection reset_cursors Tries to close all opened cursors. Examples: Reset the cursors to refresh cursor position. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) print ( conn . fetch_one ( \"SELECT * FROM customers\" )) # Ford conn . reset_cursors () print ( conn . fetch_one ( \"SELECT * FROM customers\" )) # should be Ford again Source code in prefect_snowflake/database.py def reset_cursors ( self ) -> None : \"\"\" Tries to close all opened cursors. Examples: Reset the cursors to refresh cursor position. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) print(conn.fetch_one(\"SELECT * FROM customers\")) # Ford conn.reset_cursors() print(conn.fetch_one(\"SELECT * FROM customers\")) # should be Ford again ``` \"\"\" # noqa input_hashes = tuple ( self . _unique_cursors . keys ()) for input_hash in input_hashes : cursor = self . _unique_cursors . pop ( input_hash ) try : cursor . close () except Exception as exc : self . logger . warning ( f \"Failed to close cursor for input hash { input_hash !r} : { exc } \" ) self . logger . info ( \"Successfully reset the cursors.\" ) Functions snowflake_multiquery async Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Parameters: Name Type Description Default queries List[str] The list of queries to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> as_transaction bool If True, queries are executed in a transaction. False return_transaction_control_results bool Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. False poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[List[Tuple[Any]]] List of the outputs of response.fetchall() for each query. Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_multiquery @flow def snowflake_multiquery_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_multiquery ( [ \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , \"SELECT 1,2\" ], snowflake_connector , params = { \"id_param\" : 1 }, as_transaction = True ) return result snowflake_multiquery_flow () Source code in prefect_snowflake/database.py @task async def snowflake_multiquery ( queries : List [ str ], snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , as_transaction : bool = False , return_transaction_control_results : bool = False , poll_frequency_seconds : int = 1 , ) -> List [ List [ Tuple [ Any ]]]: \"\"\" Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Args: queries: The list of queries to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. as_transaction: If True, queries are executed in a transaction. return_transaction_control_results: Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: List of the outputs of `response.fetchall()` for each query. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_multiquery @flow def snowflake_multiquery_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_multiquery( [\"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", \"SELECT 1,2\"], snowflake_connector, params={\"id_param\": 1}, as_transaction=True ) return result snowflake_multiquery_flow() ``` \"\"\" with snowflake_connector . get_connection () as connection : if as_transaction : queries . insert ( 0 , BEGIN_TRANSACTION_STATEMENT ) queries . append ( END_TRANSACTION_STATEMENT ) with connection . cursor ( cursor_type ) as cursor : results = [] for query in queries : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () results . append ( result ) # cut off results from BEGIN/COMMIT queries if as_transaction and not return_transaction_control_results : return results [ 1 : - 1 ] else : return results snowflake_query async Executes a query against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , poll_frequency_seconds : int = 1 , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: The output of `response.fetchall()`. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query( \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", snowflake_connector, params={\"id_param\": 1} ) return result snowflake_query_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () return result snowflake_query_sync async Executes a query in sync mode against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Execute a put statement. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_sync_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query_sync ( \"put file://afile.csv @mystage;\" , snowflake_connector , ) return result snowflake_query_sync_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query_sync ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query in sync mode against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. Returns: The output of `response.fetchall()`. Examples: Execute a put statement. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_sync_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query_sync( \"put file://afile.csv @mystage;\", snowflake_connector, ) return result snowflake_query_sync_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : cursor . execute ( query , params = params ) result = cursor . fetchall () return result","title":"Database"},{"location":"database/#prefect_snowflake.database","text":"Module for querying against Snowflake databases.","title":"database"},{"location":"database/#prefect_snowflake.database-classes","text":"","title":"Classes"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector","text":"Block used to manage connections with Snowflake. Upon instantiating, a connection is created and maintained for the life of the object until the close method is called. It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited. It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor will be lost. Parameters: Name Type Description Default credentials The credentials to authenticate with Snowflake. required database The name of the default database to use. required warehouse The name of the default warehouse to use. required schema The name of the default schema to use; this attribute is accessible through SnowflakeConnector(...).schema_ . required fetch_size The number of rows to fetch at a time. required poll_frequency_s The number of seconds before checking query. required Examples: Load stored Snowflake connector as a context manager: from prefect_snowflake.database import SnowflakeConnector snowflake_connector = SnowflakeConnector . load ( \"BLOCK_NAME\" ): Insert data into database and fetch results. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) results = conn . fetch_all ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Space\" } ) print ( results ) Source code in prefect_snowflake/database.py class SnowflakeConnector ( DatabaseBlock ): \"\"\" Block used to manage connections with Snowflake. Upon instantiating, a connection is created and maintained for the life of the object until the close method is called. It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited. It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor will be lost. Args: credentials: The credentials to authenticate with Snowflake. database: The name of the default database to use. warehouse: The name of the default warehouse to use. schema: The name of the default schema to use; this attribute is accessible through `SnowflakeConnector(...).schema_`. fetch_size: The number of rows to fetch at a time. poll_frequency_s: The number of seconds before checking query. Examples: Load stored Snowflake connector as a context manager: ```python from prefect_snowflake.database import SnowflakeConnector snowflake_connector = SnowflakeConnector.load(\"BLOCK_NAME\"): ``` Insert data into database and fetch results. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) results = conn.fetch_all( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Space\"} ) print(results) ``` \"\"\" # noqa _block_type_name = \"Snowflake Connector\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa _description = \"Perform data operations against a Snowflake database.\" credentials : SnowflakeCredentials = Field ( default =... , description = \"The credentials to authenticate with Snowflake.\" ) database : str = Field ( default =... , description = \"The name of the default database to use.\" ) warehouse : str = Field ( default =... , description = \"The name of the default warehouse to use.\" ) schema_ : str = Field ( default =... , alias = \"schema\" , description = \"The name of the default schema to use.\" , ) fetch_size : int = Field ( default = 1 , description = \"The default number of rows to fetch at a time.\" ) poll_frequency_s : int = Field ( default = 1 , title = \"Poll Frequency [seconds]\" , description = ( \"The number of seconds between checking query \" \"status for long running queries.\" ), ) _connection : Optional [ SnowflakeConnection ] = None _unique_cursors : Dict [ str , SnowflakeCursor ] = None def get_connection ( self , ** connect_kwargs : Dict [ str , Any ]) -> SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) with snowflake_connector.get_connection() as connection: ... ``` \"\"\" if self . _connection is not None : return self . _connection connect_params = { \"database\" : self . database , \"warehouse\" : self . warehouse , \"schema\" : self . schema_ , } connection = self . credentials . get_client ( ** connect_kwargs , ** connect_params ) return connection def _start_connection ( self ): \"\"\" Starts Snowflake database connection. \"\"\" self . _connection = self . get_connection () def block_initialization ( self ) -> None : super () . block_initialization () if self . _connection is None : self . _start_connection () if self . _unique_cursors is None : self . _unique_cursors = {} def _get_cursor ( self , inputs : Dict [ str , Any ]) -> Tuple [ bool , SnowflakeCursor ]: \"\"\" Get a Snowflake cursor. Args: inputs: The inputs to generate a unique hash, used to decide whether a new cursor should be used. Returns: Whether a cursor is new and a Snowflake cursor. \"\"\" input_hash = hash_objects ( inputs ) if input_hash is None : raise RuntimeError ( \"We were not able to hash your inputs, \" \"which resulted in an unexpected data return; \" \"please open an issue with a reproducible example.\" ) if input_hash not in self . _unique_cursors . keys (): new_cursor = self . _connection . cursor () self . _unique_cursors [ input_hash ] = new_cursor return True , new_cursor else : existing_cursor = self . _unique_cursors [ input_hash ] return False , existing_cursor async def _execute_async ( self , cursor : SnowflakeCursor , inputs : Dict [ str , Any ]): \"\"\"Helper method to execute operations asynchronously.\"\"\" response = await run_sync_in_worker_thread ( cursor . execute_async , ** inputs ) self . logger . info ( f \"Executing the operation, { inputs [ 'command' ] !r} , asynchronously; \" f \"polling for the result every { self . poll_frequency_s } seconds.\" ) query_id = response [ \"queryId\" ] while self . _connection . is_still_running ( await run_sync_in_worker_thread ( self . _connection . get_query_status_throw_if_error , query_id ) ): await asyncio . sleep ( self . poll_frequency_s ) await run_sync_in_worker_thread ( cursor . get_results_from_sfqid , query_id ) def reset_cursors ( self ) -> None : \"\"\" Tries to close all opened cursors. Examples: Reset the cursors to refresh cursor position. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) print(conn.fetch_one(\"SELECT * FROM customers\")) # Ford conn.reset_cursors() print(conn.fetch_one(\"SELECT * FROM customers\")) # should be Ford again ``` \"\"\" # noqa input_hashes = tuple ( self . _unique_cursors . keys ()) for input_hash in input_hashes : cursor = self . _unique_cursors . pop ( input_hash ) try : cursor . close () except Exception as exc : self . logger . warning ( f \"Failed to close cursor for input hash { input_hash !r} : { exc } \" ) self . logger . info ( \"Successfully reset the cursors.\" ) @sync_compatible async def fetch_one ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> Tuple [ Any ]: \"\"\" Fetch a single result from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A tuple containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch one row from the database where address is Space. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_one( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Space\"} ) print(result) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch a row.\" ) result = await run_sync_in_worker_thread ( cursor . fetchone ) return result @sync_compatible async def fetch_many ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , size : Optional [ int ] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch a limited number of results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. size: The number of results to return; if None or 0, uses the value of `fetch_size` configured on the block. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Repeatedly fetch two rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Highway 42\"}, ], ) result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Marvin, Ford result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Unknown, Me ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) size = size or self . fetch_size self . logger . debug ( f \"Preparing to fetch { size } rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchmany , size = size ) return result @sync_compatible async def fetch_all ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch all results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch all rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_all( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, ) print(result) # Marvin, Ford, Unknown ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch all rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchall ) return result @sync_compatible async def execute ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> None : \"\"\" Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Examples: Create table named customers with two columns, name and address. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . execute , ** inputs ) self . logger . info ( f \"Executed the operation, { operation !r} .\" ) @sync_compatible async def execute_many ( self , operation : str , seq_of_parameters : List [ Dict [ str , Any ]], ) -> None : \"\"\" Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling. Args: operation: The SQL query or other operation to be executed. seq_of_parameters: The sequence of parameters for the operation. Examples: Create table and insert three rows into it. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, ], ) ``` \"\"\" # noqa inputs = dict ( command = operation , seqparams = seq_of_parameters , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . executemany , ** inputs ) self . logger . info ( f \"Executed { len ( seq_of_parameters ) } operations off { operation !r} .\" ) def close ( self ): \"\"\" Closes connection and its cursors. \"\"\" try : self . reset_cursors () finally : if self . _connection is not None : self . _connection . close () self . _connection = None self . logger . info ( \"Successfully closed the Snowflake connection.\" ) def __enter__ ( self ): \"\"\" Start a connection upon entry. \"\"\" return self def __exit__ ( self , * args ): \"\"\" Closes connection and its cursors upon exit. \"\"\" self . close () def __getstate__ ( self ): \"\"\"Allows block to be pickled and dumped.\"\"\" data = self . __dict__ . copy () data . update ({ k : None for k in { \"_connection\" , \"_unique_cursors\" }}) return data def __setstate__ ( self , data : dict ): \"\"\"Reset connection and cursors upon loading.\"\"\" self . __dict__ . update ( data ) self . _unique_cursors = {} self . _start_connection ()","title":"SnowflakeConnector"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector-attributes","text":"","title":"Attributes"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.credentials","text":"The credentials to authenticate with Snowflake.","title":"credentials"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.database","text":"The name of the default database to use.","title":"database"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_size","text":"The default number of rows to fetch at a time.","title":"fetch_size"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.poll_frequency_s","text":"The number of seconds between checking query status for long running queries.","title":"poll_frequency_s"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.schema_","text":"The name of the default schema to use.","title":"schema_"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.warehouse","text":"The name of the default warehouse to use.","title":"warehouse"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector-methods","text":"","title":"Methods"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__enter__","text":"Start a connection upon entry. Source code in prefect_snowflake/database.py def __enter__ ( self ): \"\"\" Start a connection upon entry. \"\"\" return self","title":"__enter__()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__exit__","text":"Closes connection and its cursors upon exit. Source code in prefect_snowflake/database.py def __exit__ ( self , * args ): \"\"\" Closes connection and its cursors upon exit. \"\"\" self . close ()","title":"__exit__()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__getstate__","text":"Allows block to be pickled and dumped. Source code in prefect_snowflake/database.py def __getstate__ ( self ): \"\"\"Allows block to be pickled and dumped.\"\"\" data = self . __dict__ . copy () data . update ({ k : None for k in { \"_connection\" , \"_unique_cursors\" }}) return data","title":"__getstate__()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__setstate__","text":"Reset connection and cursors upon loading. Source code in prefect_snowflake/database.py def __setstate__ ( self , data : dict ): \"\"\"Reset connection and cursors upon loading.\"\"\" self . __dict__ . update ( data ) self . _unique_cursors = {} self . _start_connection ()","title":"__setstate__()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.close","text":"Closes connection and its cursors. Source code in prefect_snowflake/database.py def close ( self ): \"\"\" Closes connection and its cursors. \"\"\" try : self . reset_cursors () finally : if self . _connection is not None : self . _connection . close () self . _connection = None self . logger . info ( \"Successfully closed the Snowflake connection.\" )","title":"close()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.execute","text":"Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Examples: Create table named customers with two columns, name and address. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) Source code in prefect_snowflake/database.py @sync_compatible async def execute ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> None : \"\"\" Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operation upon calling. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Examples: Create table named customers with two columns, name and address. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . execute , ** inputs ) self . logger . info ( f \"Executed the operation, { operation !r} .\" )","title":"execute()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.execute_many","text":"Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required seq_of_parameters List[Dict[str, Any]] The sequence of parameters for the operation. required Examples: Create table and insert three rows into it. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Marvin\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, ], ) Source code in prefect_snowflake/database.py @sync_compatible async def execute_many ( self , operation : str , seq_of_parameters : List [ Dict [ str , Any ]], ) -> None : \"\"\" Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE. Unlike the fetch methods, this method will always execute the operations upon calling. Args: operation: The SQL query or other operation to be executed. seq_of_parameters: The sequence of parameters for the operation. Examples: Create table and insert three rows into it. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, ], ) ``` \"\"\" # noqa inputs = dict ( command = operation , seqparams = seq_of_parameters , ) with self . _connection . cursor () as cursor : await run_sync_in_worker_thread ( cursor . executemany , ** inputs ) self . logger . info ( f \"Executed { len ( seq_of_parameters ) } operations off { operation !r} .\" )","title":"execute_many()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_all","text":"Fetch all results from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Returns: Type Description List[Tuple[Any]] A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch all rows from the database where address is Highway 42. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Marvin\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) result = conn . fetch_all ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Highway 42\" }, ) print ( result ) # Marvin, Ford, Unknown Source code in prefect_snowflake/database.py @sync_compatible async def fetch_all ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch all results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch all rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_all( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, ) print(result) # Marvin, Ford, Unknown ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch all rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchall ) return result","title":"fetch_all()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_many","text":"Fetch a limited number of results from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None size Optional[int] The number of results to return; if None or 0, uses the value of fetch_size configured on the block. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Returns: Type Description List[Tuple[Any]] A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Repeatedly fetch two rows from the database where address is Highway 42. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Marvin\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Me\" , \"address\" : \"Highway 42\" }, ], ) result = conn . fetch_many ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Highway 42\" }, size = 2 ) print ( result ) # Marvin, Ford result = conn . fetch_many ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Highway 42\" }, size = 2 ) print ( result ) # Unknown, Me Source code in prefect_snowflake/database.py @sync_compatible async def fetch_many ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , size : Optional [ int ] = None , ** execute_kwargs : Dict [ str , Any ], ) -> List [ Tuple [ Any ]]: \"\"\" Fetch a limited number of results from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. size: The number of results to return; if None or 0, uses the value of `fetch_size` configured on the block. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Repeatedly fetch two rows from the database where address is Highway 42. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Marvin\", \"address\": \"Highway 42\"}, {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Highway 42\"}, {\"name\": \"Me\", \"address\": \"Highway 42\"}, ], ) result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Marvin, Ford result = conn.fetch_many( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Highway 42\"}, size=2 ) print(result) # Unknown, Me ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) size = size or self . fetch_size self . logger . debug ( f \"Preparing to fetch { size } rows.\" ) result = await run_sync_in_worker_thread ( cursor . fetchmany , size = size ) return result","title":"fetch_many()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.fetch_one","text":"Fetch a single result from the database. Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Parameters: Name Type Description Default operation str The SQL query or other operation to be executed. required parameters Optional[Dict[str, Any]] The parameters for the operation. None **execute_kwargs Dict[str, Any] Additional options to pass to cursor.execute_async . {} Returns: Type Description Tuple[Any] A tuple containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch one row from the database where address is Space. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) result = conn . fetch_one ( \"SELECT * FROM customers WHERE address = %(address)s \" , parameters = { \"address\" : \"Space\" } ) print ( result ) Source code in prefect_snowflake/database.py @sync_compatible async def fetch_one ( self , operation : str , parameters : Optional [ Dict [ str , Any ]] = None , ** execute_kwargs : Dict [ str , Any ], ) -> Tuple [ Any ]: \"\"\" Fetch a single result from the database. Repeated calls using the same inputs to *any* of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called. Args: operation: The SQL query or other operation to be executed. parameters: The parameters for the operation. **execute_kwargs: Additional options to pass to `cursor.execute_async`. Returns: A tuple containing the data returned by the database, where each row is a tuple and each column is a value in the tuple. Examples: Fetch one row from the database where address is Space. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) result = conn.fetch_one( \"SELECT * FROM customers WHERE address = %(address)s\", parameters={\"address\": \"Space\"} ) print(result) ``` \"\"\" # noqa inputs = dict ( command = operation , params = parameters , ** execute_kwargs , ) new , cursor = self . _get_cursor ( inputs ) if new : await self . _execute_async ( cursor , inputs ) self . logger . debug ( \"Preparing to fetch a row.\" ) result = await run_sync_in_worker_thread ( cursor . fetchone ) return result","title":"fetch_one()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.get_connection","text":"Returns an authenticated connection that can be used to query from Snowflake databases. Parameters: Name Type Description Default **connect_kwargs Dict[str, Any] Additional arguments to pass to snowflake.connector.connect . {} Returns: Type Description SnowflakeConnection The authenticated SnowflakeConnection. Examples: from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) with snowflake_connector . get_connection () as connection : ... Source code in prefect_snowflake/database.py def get_connection ( self , ** connect_kwargs : Dict [ str , Any ]) -> SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Args: **connect_kwargs: Additional arguments to pass to `snowflake.connector.connect`. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) with snowflake_connector.get_connection() as connection: ... ``` \"\"\" if self . _connection is not None : return self . _connection connect_params = { \"database\" : self . database , \"warehouse\" : self . warehouse , \"schema\" : self . schema_ , } connection = self . credentials . get_client ( ** connect_kwargs , ** connect_params ) return connection","title":"get_connection()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.reset_cursors","text":"Tries to close all opened cursors. Examples: Reset the cursors to refresh cursor position. from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector . load ( \"BLOCK_NAME\" ) as conn : conn . execute ( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn . execute_many ( \"INSERT INTO customers (name, address) VALUES ( %(name)s , %(address)s );\" , seq_of_parameters = [ { \"name\" : \"Ford\" , \"address\" : \"Highway 42\" }, { \"name\" : \"Unknown\" , \"address\" : \"Space\" }, { \"name\" : \"Me\" , \"address\" : \"Myway 88\" }, ], ) print ( conn . fetch_one ( \"SELECT * FROM customers\" )) # Ford conn . reset_cursors () print ( conn . fetch_one ( \"SELECT * FROM customers\" )) # should be Ford again Source code in prefect_snowflake/database.py def reset_cursors ( self ) -> None : \"\"\" Tries to close all opened cursors. Examples: Reset the cursors to refresh cursor position. ```python from prefect_snowflake.database import SnowflakeConnector with SnowflakeConnector.load(\"BLOCK_NAME\") as conn: conn.execute( \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\" ) conn.execute_many( \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\", seq_of_parameters=[ {\"name\": \"Ford\", \"address\": \"Highway 42\"}, {\"name\": \"Unknown\", \"address\": \"Space\"}, {\"name\": \"Me\", \"address\": \"Myway 88\"}, ], ) print(conn.fetch_one(\"SELECT * FROM customers\")) # Ford conn.reset_cursors() print(conn.fetch_one(\"SELECT * FROM customers\")) # should be Ford again ``` \"\"\" # noqa input_hashes = tuple ( self . _unique_cursors . keys ()) for input_hash in input_hashes : cursor = self . _unique_cursors . pop ( input_hash ) try : cursor . close () except Exception as exc : self . logger . warning ( f \"Failed to close cursor for input hash { input_hash !r} : { exc } \" ) self . logger . info ( \"Successfully reset the cursors.\" )","title":"reset_cursors()"},{"location":"database/#prefect_snowflake.database-functions","text":"","title":"Functions"},{"location":"database/#prefect_snowflake.database.snowflake_multiquery","text":"Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Parameters: Name Type Description Default queries List[str] The list of queries to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> as_transaction bool If True, queries are executed in a transaction. False return_transaction_control_results bool Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. False poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[List[Tuple[Any]]] List of the outputs of response.fetchall() for each query. Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_multiquery @flow def snowflake_multiquery_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_multiquery ( [ \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , \"SELECT 1,2\" ], snowflake_connector , params = { \"id_param\" : 1 }, as_transaction = True ) return result snowflake_multiquery_flow () Source code in prefect_snowflake/database.py @task async def snowflake_multiquery ( queries : List [ str ], snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , as_transaction : bool = False , return_transaction_control_results : bool = False , poll_frequency_seconds : int = 1 , ) -> List [ List [ Tuple [ Any ]]]: \"\"\" Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Args: queries: The list of queries to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. as_transaction: If True, queries are executed in a transaction. return_transaction_control_results: Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: List of the outputs of `response.fetchall()` for each query. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_multiquery @flow def snowflake_multiquery_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_multiquery( [\"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", \"SELECT 1,2\"], snowflake_connector, params={\"id_param\": 1}, as_transaction=True ) return result snowflake_multiquery_flow() ``` \"\"\" with snowflake_connector . get_connection () as connection : if as_transaction : queries . insert ( 0 , BEGIN_TRANSACTION_STATEMENT ) queries . append ( END_TRANSACTION_STATEMENT ) with connection . cursor ( cursor_type ) as cursor : results = [] for query in queries : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () results . append ( result ) # cut off results from BEGIN/COMMIT queries if as_transaction and not return_transaction_control_results : return results [ 1 : - 1 ] else : return results","title":"snowflake_multiquery()"},{"location":"database/#prefect_snowflake.database.snowflake_query","text":"Executes a query against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , poll_frequency_seconds : int = 1 , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: The output of `response.fetchall()`. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query( \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", snowflake_connector, params={\"id_param\": 1} ) return result snowflake_query_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () return result","title":"snowflake_query()"},{"location":"database/#prefect_snowflake.database.snowflake_query_sync","text":"Executes a query in sync mode against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Execute a put statement. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_sync_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query_sync ( \"put file://afile.csv @mystage;\" , snowflake_connector , ) return result snowflake_query_sync_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query_sync ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query in sync mode against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. Returns: The output of `response.fetchall()`. Examples: Execute a put statement. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_sync_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query_sync( \"put file://afile.csv @mystage;\", snowflake_connector, ) return result snowflake_query_sync_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : cursor . execute ( query , params = params ) result = cursor . fetchall () return result","title":"snowflake_query_sync()"}]}