{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-snowflake Welcome! Prefect integrations for interacting with prefect-snowflake. Getting Started Python setup Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-snowflake with pip : pip install prefect-snowflake Then, register to view the block on Prefect Cloud: prefect block register -m prefect_snowflake.credentials Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI . Query from table from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow () Write pandas to table using block attributes import pandas as pd from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query from snowflake.connector.pandas_tools import write_pandas @flow def snowflake_write_pandas_flow (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) with snowflake_connector . get_connection () as conn : table_name = \"TABLE_NAME\" ddl = \"NAME STRING, NUMBER INT\" statement = f 'CREATE TABLE IF NOT EXISTS { table_name } ( { ddl } )' with conn . cursor () as cur : cur . execute ( statement ) # case sensitivity matters here! df = pd . DataFrame ([( 'Marvin' , 42 ), ( 'Ford' , 88 )], columns = [ 'NAME' , 'NUMBER' ]) success , num_chunks , num_rows , _ = write_pandas ( conn = conn , df = df , table_name = table_name , database = snowflake_connector . database , schema = snowflake_connector . schema_ # note the \"_\" suffix ) Execute get and put statements To execute get and put statements, use snowflake_query_sync . from prefect import flow from prefect_snowflake.database import SnowflakeConnector , snowflake_query_sync @flow def snowflake_put_file_to_snowflake_stage (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) snowflake_query_sync ( f \"put file:///myfolder/myfile @mystage/mystagepath\" , snowflake_connector = snowflake_connector ) Resources If you encounter any bugs while using prefect-snowflake , feel free to open an issue in the prefect-snowflake repository. If you have any questions or issues while using prefect-snowflake , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to \u2b50\ufe0f or watch prefect-snowflake for updates too! Development If you'd like to install a version of prefect-snowflake for development, clone the repository and perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-snowflake.git cd prefect-snowflake/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Home"},{"location":"#prefect-snowflake","text":"","title":"prefect-snowflake"},{"location":"#welcome","text":"Prefect integrations for interacting with prefect-snowflake.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-snowflake with pip : pip install prefect-snowflake Then, register to view the block on Prefect Cloud: prefect block register -m prefect_snowflake.credentials Note, to use the load method on Blocks, you must already have a block document saved through code or saved through the UI .","title":"Installation"},{"location":"#query-from-table","text":"from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow ()","title":"Query from table"},{"location":"#write-pandas-to-table-using-block-attributes","text":"import pandas as pd from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query from snowflake.connector.pandas_tools import write_pandas @flow def snowflake_write_pandas_flow (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) with snowflake_connector . get_connection () as conn : table_name = \"TABLE_NAME\" ddl = \"NAME STRING, NUMBER INT\" statement = f 'CREATE TABLE IF NOT EXISTS { table_name } ( { ddl } )' with conn . cursor () as cur : cur . execute ( statement ) # case sensitivity matters here! df = pd . DataFrame ([( 'Marvin' , 42 ), ( 'Ford' , 88 )], columns = [ 'NAME' , 'NUMBER' ]) success , num_chunks , num_rows , _ = write_pandas ( conn = conn , df = df , table_name = table_name , database = snowflake_connector . database , schema = snowflake_connector . schema_ # note the \"_\" suffix )","title":"Write pandas to table using block attributes"},{"location":"#execute-get-and-put-statements","text":"To execute get and put statements, use snowflake_query_sync . from prefect import flow from prefect_snowflake.database import SnowflakeConnector , snowflake_query_sync @flow def snowflake_put_file_to_snowflake_stage (): snowflake_connector = SnowflakeConnector . load ( \"my-block\" ) snowflake_query_sync ( f \"put file:///myfolder/myfile @mystage/mystagepath\" , snowflake_connector = snowflake_connector )","title":"Execute get and put statements"},{"location":"#resources","text":"If you encounter any bugs while using prefect-snowflake , feel free to open an issue in the prefect-snowflake repository. If you have any questions or issues while using prefect-snowflake , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to \u2b50\ufe0f or watch prefect-snowflake for updates too!","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-snowflake for development, clone the repository and perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-snowflake.git cd prefect-snowflake/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Development"},{"location":"credentials/","text":"prefect_snowflake.credentials Credentials class to authenticate Snowflake. InvalidPemFormat Invalid PEM Format Certificate Source code in prefect_snowflake/credentials.py class InvalidPemFormat ( Exception ): \"\"\"Invalid PEM Format Certificate\"\"\" SnowflakeCredentials pydantic-model Block used to manage authentication with Snowflake. Parameters: Name Type Description Default account str The snowflake account name. required user str The user name used to authenticate. required password SecretStr The password used to authenticate. required private_key SecretStr The PEM used to authenticate. required authenticator str The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to Snowflake documentation for details, and note that externalbrowser will only work in an environment where a browser is available. required token SecretStr The OAuth or JWT Token to provide when authenticator is set to OAuth. required okta_endpoint str The Okta endpoint to use when authenticator is set to okta_endpoint , e.g. https://<okta_account_name>.okta.com . required role str The name of the default role to use. required autocommit bool Whether to automatically commit. required Examples: Load stored Snowflake credentials: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) Source code in prefect_snowflake/credentials.py class SnowflakeCredentials ( Block ): \"\"\" Block used to manage authentication with Snowflake. Args: account (str): The snowflake account name. user (str): The user name used to authenticate. password (SecretStr): The password used to authenticate. private_key (SecretStr): The PEM used to authenticate. authenticator (str): The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to [Snowflake documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect) for details, and note that `externalbrowser` will only work in an environment where a browser is available. token (SecretStr): The OAuth or JWT Token to provide when authenticator is set to OAuth. okta_endpoint (str): The Okta endpoint to use when authenticator is set to `okta_endpoint`, e.g. `https://<okta_account_name>.okta.com`. role (str): The name of the default role to use. autocommit (bool): Whether to automatically commit. Example: Load stored Snowflake credentials: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") ``` \"\"\" # noqa E501 _block_type_name = \"Snowflake Credentials\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa account : str = Field ( ... , description = \"The snowflake account name\" ) user : str = Field ( ... , description = \"The user name used to authenticate\" ) password : Optional [ SecretStr ] = Field ( default = None , description = \"The password used to authenticate\" ) private_key : Optional [ SecretBytes ] = Field ( default = None , description = \"The PEM used to authenticate\" ) authenticator : Literal [ \"snowflake\" , \"externalbrowser\" , \"okta_endpoint\" , \"oauth\" , \"username_password_mfa\" , ] = Field ( # noqa default = \"snowflake\" , description = ( \"The type of authenticator to use for initializing connection\" ), ) token : Optional [ SecretStr ] = Field ( default = None , description = ( \"The OAuth or JWT Token to provide when authenticator is set to `oauth`\" ), ) endpoint : Optional [ str ] = Field ( default = None , description = ( \"The Okta endpoint to use when authenticator is set to `okta_endpoint`\" ), ) role : Optional [ str ] = Field ( default = None , description = \"The name of the default role to use\" ) autocommit : Optional [ bool ] = Field ( default = None , description = \"Whether to automatically commit\" ) @root_validator ( pre = True ) def _validate_auth_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" auth_params = ( \"password\" , \"private_key\" , \"authenticator\" , \"token\" ) if not any ( values . get ( param ) for param in auth_params ): auth_str = \", \" . join ( auth_params ) raise ValueError ( f \"One of the authentication keys must be provided: { auth_str } \\n \" ) return values @root_validator ( pre = True ) def _validate_token_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) token = values . get ( \"token\" ) if authenticator == \"oauth\" and not token : raise ValueError ( \"If authenticator is set to `oauth`, `token` must be provided\" ) return values @root_validator ( pre = True ) def _validate_okta_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) # did not want to make a breaking change so we will allow both # see https://github.com/PrefectHQ/prefect-snowflake/issues/44 if \"okta_endpoint\" in values . keys (): warnings . warn ( \"Please specify `endpoint` instead of `okta_endpoint`.\" , DeprecationWarning , ) # remove okta endpoint from fields okta_endpoint = values . pop ( \"okta_endpoint\" ) if \"endpoint\" not in values . keys (): values [ \"endpoint\" ] = okta_endpoint endpoint = values . get ( \"endpoint\" ) if authenticator == \"okta_endpoint\" and not endpoint : raise ValueError ( \"If authenticator is set to `okta_endpoint`, \" \"`endpoint` must be provided\" ) return values @validator ( \"private_key\" ) def _validate_private_key ( cls , private_key ): \"\"\" Ensure a private_key looks like a PEM format certificate. \"\"\" if private_key is None : return None assert isinstance ( private_key , SecretBytes ) pk = cls . _decode_secret ( private_key ) return None if pk is None else SecretBytes ( cls . _compose_pem ( pk )) def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), ) @staticmethod def _decode_secret ( secret : Union [ SecretStr , SecretBytes ]) -> Optional [ bytes ]: \"\"\" Decode the provided secret into bytes. If the secret is not a string or bytes, or it is whitespace, then return None. Args: secret: The value to decode. Returns: The decoded secret as bytes. \"\"\" if isinstance ( secret , ( SecretBytes , SecretStr )): secret = secret . get_secret_value () if not isinstance ( secret , ( bytes , str )) or len ( secret ) == 0 or secret . isspace (): return None return secret if isinstance ( secret , bytes ) else secret . encode () @staticmethod def _compose_pem ( private_key : bytes ) -> bytes : \"\"\"Validate structure of PEM certificate. The original key passed from Prefect is sometimes malformed. This function recomposes the key into a valid key that will pass the serialization step when resolving the key to a DER. Args: private_key: A valid PEM format byte encoded string. Returns: byte encoded certificate. Raises: InvalidPemFormat: if private key is an invalid format. \"\"\" pem_parts = re . match ( _SIMPLE_PEM_CERTIFICATE_REGEX , private_key . decode ()) if pem_parts is None : raise InvalidPemFormat () body = \" \\n \" . join ( re . split ( r \"\\s+\" , pem_parts [ 2 ] . strip ())) # reassemble header+body+footer return f \" { pem_parts [ 1 ] } \\n { body } \\n { pem_parts [ 3 ] } \" . encode () account : str pydantic-field required The snowflake account name authenticator : Literal [ 'snowflake' , 'externalbrowser' , 'okta_endpoint' , 'oauth' , 'username_password_mfa' ] pydantic-field The type of authenticator to use for initializing connection autocommit : bool pydantic-field Whether to automatically commit endpoint : str pydantic-field The Okta endpoint to use when authenticator is set to okta_endpoint password : SecretStr pydantic-field The password used to authenticate private_key : SecretBytes pydantic-field The PEM used to authenticate role : str pydantic-field The name of the default role to use token : SecretStr pydantic-field The OAuth or JWT Token to provide when authenticator is set to oauth user : str pydantic-field required The user name used to authenticate __json_encoder__ special staticmethod partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. resolve_private_key Converts a PEM encoded private key into a DER binary key. Returns: Type Description Optional[bytes] DER encoded key if private_key has been provided otherwise returns None. Exceptions: Type Description InvalidPemFormat If private key is not in PEM format. Source code in prefect_snowflake/credentials.py def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), )","title":"Credentials"},{"location":"credentials/#prefect_snowflake.credentials","text":"Credentials class to authenticate Snowflake.","title":"credentials"},{"location":"credentials/#prefect_snowflake.credentials.InvalidPemFormat","text":"Invalid PEM Format Certificate Source code in prefect_snowflake/credentials.py class InvalidPemFormat ( Exception ): \"\"\"Invalid PEM Format Certificate\"\"\"","title":"InvalidPemFormat"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials","text":"Block used to manage authentication with Snowflake. Parameters: Name Type Description Default account str The snowflake account name. required user str The user name used to authenticate. required password SecretStr The password used to authenticate. required private_key SecretStr The PEM used to authenticate. required authenticator str The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to Snowflake documentation for details, and note that externalbrowser will only work in an environment where a browser is available. required token SecretStr The OAuth or JWT Token to provide when authenticator is set to OAuth. required okta_endpoint str The Okta endpoint to use when authenticator is set to okta_endpoint , e.g. https://<okta_account_name>.okta.com . required role str The name of the default role to use. required autocommit bool Whether to automatically commit. required Examples: Load stored Snowflake credentials: from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials . load ( \"BLOCK_NAME\" ) Source code in prefect_snowflake/credentials.py class SnowflakeCredentials ( Block ): \"\"\" Block used to manage authentication with Snowflake. Args: account (str): The snowflake account name. user (str): The user name used to authenticate. password (SecretStr): The password used to authenticate. private_key (SecretStr): The PEM used to authenticate. authenticator (str): The type of authenticator to use for initializing connection (oauth, externalbrowser, etc); refer to [Snowflake documentation](https://docs.snowflake.com/en/user-guide/python-connector-api.html#connect) for details, and note that `externalbrowser` will only work in an environment where a browser is available. token (SecretStr): The OAuth or JWT Token to provide when authenticator is set to OAuth. okta_endpoint (str): The Okta endpoint to use when authenticator is set to `okta_endpoint`, e.g. `https://<okta_account_name>.okta.com`. role (str): The name of the default role to use. autocommit (bool): Whether to automatically commit. Example: Load stored Snowflake credentials: ```python from prefect_snowflake import SnowflakeCredentials snowflake_credentials_block = SnowflakeCredentials.load(\"BLOCK_NAME\") ``` \"\"\" # noqa E501 _block_type_name = \"Snowflake Credentials\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa account : str = Field ( ... , description = \"The snowflake account name\" ) user : str = Field ( ... , description = \"The user name used to authenticate\" ) password : Optional [ SecretStr ] = Field ( default = None , description = \"The password used to authenticate\" ) private_key : Optional [ SecretBytes ] = Field ( default = None , description = \"The PEM used to authenticate\" ) authenticator : Literal [ \"snowflake\" , \"externalbrowser\" , \"okta_endpoint\" , \"oauth\" , \"username_password_mfa\" , ] = Field ( # noqa default = \"snowflake\" , description = ( \"The type of authenticator to use for initializing connection\" ), ) token : Optional [ SecretStr ] = Field ( default = None , description = ( \"The OAuth or JWT Token to provide when authenticator is set to `oauth`\" ), ) endpoint : Optional [ str ] = Field ( default = None , description = ( \"The Okta endpoint to use when authenticator is set to `okta_endpoint`\" ), ) role : Optional [ str ] = Field ( default = None , description = \"The name of the default role to use\" ) autocommit : Optional [ bool ] = Field ( default = None , description = \"Whether to automatically commit\" ) @root_validator ( pre = True ) def _validate_auth_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" auth_params = ( \"password\" , \"private_key\" , \"authenticator\" , \"token\" ) if not any ( values . get ( param ) for param in auth_params ): auth_str = \", \" . join ( auth_params ) raise ValueError ( f \"One of the authentication keys must be provided: { auth_str } \\n \" ) return values @root_validator ( pre = True ) def _validate_token_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) token = values . get ( \"token\" ) if authenticator == \"oauth\" and not token : raise ValueError ( \"If authenticator is set to `oauth`, `token` must be provided\" ) return values @root_validator ( pre = True ) def _validate_okta_kwargs ( cls , values ): \"\"\" Ensure an authorization value has been provided by the user. \"\"\" authenticator = values . get ( \"authenticator\" ) # did not want to make a breaking change so we will allow both # see https://github.com/PrefectHQ/prefect-snowflake/issues/44 if \"okta_endpoint\" in values . keys (): warnings . warn ( \"Please specify `endpoint` instead of `okta_endpoint`.\" , DeprecationWarning , ) # remove okta endpoint from fields okta_endpoint = values . pop ( \"okta_endpoint\" ) if \"endpoint\" not in values . keys (): values [ \"endpoint\" ] = okta_endpoint endpoint = values . get ( \"endpoint\" ) if authenticator == \"okta_endpoint\" and not endpoint : raise ValueError ( \"If authenticator is set to `okta_endpoint`, \" \"`endpoint` must be provided\" ) return values @validator ( \"private_key\" ) def _validate_private_key ( cls , private_key ): \"\"\" Ensure a private_key looks like a PEM format certificate. \"\"\" if private_key is None : return None assert isinstance ( private_key , SecretBytes ) pk = cls . _decode_secret ( private_key ) return None if pk is None else SecretBytes ( cls . _compose_pem ( pk )) def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), ) @staticmethod def _decode_secret ( secret : Union [ SecretStr , SecretBytes ]) -> Optional [ bytes ]: \"\"\" Decode the provided secret into bytes. If the secret is not a string or bytes, or it is whitespace, then return None. Args: secret: The value to decode. Returns: The decoded secret as bytes. \"\"\" if isinstance ( secret , ( SecretBytes , SecretStr )): secret = secret . get_secret_value () if not isinstance ( secret , ( bytes , str )) or len ( secret ) == 0 or secret . isspace (): return None return secret if isinstance ( secret , bytes ) else secret . encode () @staticmethod def _compose_pem ( private_key : bytes ) -> bytes : \"\"\"Validate structure of PEM certificate. The original key passed from Prefect is sometimes malformed. This function recomposes the key into a valid key that will pass the serialization step when resolving the key to a DER. Args: private_key: A valid PEM format byte encoded string. Returns: byte encoded certificate. Raises: InvalidPemFormat: if private key is an invalid format. \"\"\" pem_parts = re . match ( _SIMPLE_PEM_CERTIFICATE_REGEX , private_key . decode ()) if pem_parts is None : raise InvalidPemFormat () body = \" \\n \" . join ( re . split ( r \"\\s+\" , pem_parts [ 2 ] . strip ())) # reassemble header+body+footer return f \" { pem_parts [ 1 ] } \\n { body } \\n { pem_parts [ 3 ] } \" . encode ()","title":"SnowflakeCredentials"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.account","text":"The snowflake account name","title":"account"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.authenticator","text":"The type of authenticator to use for initializing connection","title":"authenticator"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.autocommit","text":"Whether to automatically commit","title":"autocommit"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.endpoint","text":"The Okta endpoint to use when authenticator is set to okta_endpoint","title":"endpoint"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.password","text":"The password used to authenticate","title":"password"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.private_key","text":"The PEM used to authenticate","title":"private_key"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.role","text":"The name of the default role to use","title":"role"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.token","text":"The OAuth or JWT Token to provide when authenticator is set to oauth","title":"token"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.user","text":"The user name used to authenticate","title":"user"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"credentials/#prefect_snowflake.credentials.SnowflakeCredentials.resolve_private_key","text":"Converts a PEM encoded private key into a DER binary key. Returns: Type Description Optional[bytes] DER encoded key if private_key has been provided otherwise returns None. Exceptions: Type Description InvalidPemFormat If private key is not in PEM format. Source code in prefect_snowflake/credentials.py def resolve_private_key ( self ) -> Optional [ bytes ]: \"\"\" Converts a PEM encoded private key into a DER binary key. Returns: DER encoded key if private_key has been provided otherwise returns None. Raises: InvalidPemFormat: If private key is not in PEM format. \"\"\" private_key = self . _decode_secret ( self . private_key ) if private_key is None : return None return load_pem_private_key ( data = private_key , password = self . _decode_secret ( self . password ), backend = default_backend (), ) . private_bytes ( encoding = Encoding . DER , format = PrivateFormat . PKCS8 , encryption_algorithm = NoEncryption (), )","title":"resolve_private_key()"},{"location":"database/","text":"prefect_snowflake.database Module for querying against Snowflake database. SnowflakeConnector pydantic-model Block used to manage connections with Snowflake. Parameters: Name Type Description Default database str The name of the default database to use. required warehouse str The name of the default warehouse to use. required schema str The name of the default schema to use; this attribute is accessible through SnowflakeConnector(...).schema_ . required credentials SnowflakeCredentials The credentials to authenticate with Snowflake. required Examples: Load stored Snowflake connector: from prefect_snowflake.database import SnowflakeConnector snowflake_connector_block = SnowflakeConnector . load ( \"BLOCK_NAME\" ) Source code in prefect_snowflake/database.py class SnowflakeConnector ( Block ): \"\"\" Block used to manage connections with Snowflake. Args: database (str): The name of the default database to use. warehouse (str): The name of the default warehouse to use. schema (str): The name of the default schema to use; this attribute is accessible through `SnowflakeConnector(...).schema_`. credentials (SnowflakeCredentials): The credentials to authenticate with Snowflake. Example: Load stored Snowflake connector: ```python from prefect_snowflake.database import SnowflakeConnector snowflake_connector_block = SnowflakeConnector.load(\"BLOCK_NAME\") ``` \"\"\" # noqa _block_type_name = \"Snowflake Connector\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa database : str = Field ( ... , descriptions = \"The name of the default database to use\" ) warehouse : str = Field ( ... , description = \"The name of the default warehouse to use\" ) schema_ : str = Field ( alias = \"schema\" , description = \"The name of the default schema to use\" ) credentials : SnowflakeCredentials def _get_connect_params ( self ) -> Dict [ str , str ]: \"\"\" Creates a connect params mapping to pass into get_connection. \"\"\" connect_params = { \"database\" : self . database , \"warehouse\" : self . warehouse , \"schema\" : self . schema_ , # required to track task's usage in the Snowflake Partner Network Portal \"application\" : \"Prefect_Snowflake_Collection\" , ** self . credentials . dict (), } # filter out unset values connect_params = { param : value for param , value in connect_params . items () if value is not None } for param in ( \"password\" , \"private_key\" , \"token\" ): if param in connect_params : connect_params [ param ] = connect_params [ param ] . get_secret_value () # set authenticator to the actual okta_endpoint if connect_params . get ( \"authenticator\" ) == \"okta_endpoint\" : endpoint = connect_params . pop ( \"endpoint\" , None ) or connect_params . pop ( \"okta_endpoint\" , None ) # okta_endpoint is deprecated connect_params [ \"authenticator\" ] = endpoint private_der_key = self . credentials . resolve_private_key () if private_der_key is not None : connect_params [ \"private_key\" ] = private_der_key connect_params . pop ( \"password\" , None ) return connect_params def get_connection ( self ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector @flow def get_connection_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) print(snowflake_connector.get_connection()) get_connection_flow() ``` \"\"\" connect_params = self . _get_connect_params () connection = snowflake . connector . connect ( ** connect_params ) return connection schema_ : str pydantic-field required The name of the default schema to use warehouse : str pydantic-field required The name of the default warehouse to use __json_encoder__ special staticmethod partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. get_connection Returns an authenticated connection that can be used to query from Snowflake databases. Returns: Type Description SnowflakeConnection The authenticated SnowflakeConnection. Examples: from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector @flow def get_connection_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) print ( snowflake_connector . get_connection ()) get_connection_flow () Source code in prefect_snowflake/database.py def get_connection ( self ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector @flow def get_connection_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) print(snowflake_connector.get_connection()) get_connection_flow() ``` \"\"\" connect_params = self . _get_connect_params () connection = snowflake . connector . connect ( ** connect_params ) return connection snowflake_multiquery async Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Parameters: Name Type Description Default queries List[str] The list of queries to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> as_transaction bool If True, queries are executed in a transaction. False return_transaction_control_results bool Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. False poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[List[Tuple[Any]]] List of the outputs of response.fetchall() for each query. Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_multiquery @flow def snowflake_multiquery_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_multiquery ( [ \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , \"SELECT 1,2\" ], snowflake_connector , params = { \"id_param\" : 1 }, as_transaction = True ) return result snowflake_multiquery_flow () Source code in prefect_snowflake/database.py @task async def snowflake_multiquery ( queries : List [ str ], snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , as_transaction : bool = False , return_transaction_control_results : bool = False , poll_frequency_seconds : int = 1 , ) -> List [ List [ Tuple [ Any ]]]: \"\"\" Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Args: queries: The list of queries to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. as_transaction: If True, queries are executed in a transaction. return_transaction_control_results: Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: List of the outputs of `response.fetchall()` for each query. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_multiquery @flow def snowflake_multiquery_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_multiquery( [\"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", \"SELECT 1,2\"], snowflake_connector, params={\"id_param\": 1}, as_transaction=True ) return result snowflake_multiquery_flow() ``` \"\"\" with snowflake_connector . get_connection () as connection : if as_transaction : queries . insert ( 0 , BEGIN_TRANSACTION_STATEMENT ) queries . append ( END_TRANSACTION_STATEMENT ) with connection . cursor ( cursor_type ) as cursor : results = [] for query in queries : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () results . append ( result ) # cut off results from BEGIN/COMMIT queries if as_transaction and not return_transaction_control_results : return results [ 1 : - 1 ] else : return results snowflake_query async Executes a query against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , poll_frequency_seconds : int = 1 , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: The output of `response.fetchall()`. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query( \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", snowflake_connector, params={\"id_param\": 1} ) return result snowflake_query_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () return result snowflake_query_sync async Executes a query in sync mode against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Execute a put statement. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_sync_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query_sync ( \"put file://afile.csv @mystage;\" , snowflake_connector , ) return result snowflake_query_sync_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query_sync ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query in sync mode against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. Returns: The output of `response.fetchall()`. Examples: Execute a put statement. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_sync_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query_sync( \"put file://afile.csv @mystage;\", snowflake_connector, ) return result snowflake_query_sync_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : cursor . execute ( query , params = params ) result = cursor . fetchall () return result","title":"Database"},{"location":"database/#prefect_snowflake.database","text":"Module for querying against Snowflake database.","title":"database"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector","text":"Block used to manage connections with Snowflake. Parameters: Name Type Description Default database str The name of the default database to use. required warehouse str The name of the default warehouse to use. required schema str The name of the default schema to use; this attribute is accessible through SnowflakeConnector(...).schema_ . required credentials SnowflakeCredentials The credentials to authenticate with Snowflake. required Examples: Load stored Snowflake connector: from prefect_snowflake.database import SnowflakeConnector snowflake_connector_block = SnowflakeConnector . load ( \"BLOCK_NAME\" ) Source code in prefect_snowflake/database.py class SnowflakeConnector ( Block ): \"\"\" Block used to manage connections with Snowflake. Args: database (str): The name of the default database to use. warehouse (str): The name of the default warehouse to use. schema (str): The name of the default schema to use; this attribute is accessible through `SnowflakeConnector(...).schema_`. credentials (SnowflakeCredentials): The credentials to authenticate with Snowflake. Example: Load stored Snowflake connector: ```python from prefect_snowflake.database import SnowflakeConnector snowflake_connector_block = SnowflakeConnector.load(\"BLOCK_NAME\") ``` \"\"\" # noqa _block_type_name = \"Snowflake Connector\" _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2DxzAeTM9eHLDcRQx1FR34/f858a501cdff918d398b39365ec2150f/snowflake.png?h=250\" # noqa database : str = Field ( ... , descriptions = \"The name of the default database to use\" ) warehouse : str = Field ( ... , description = \"The name of the default warehouse to use\" ) schema_ : str = Field ( alias = \"schema\" , description = \"The name of the default schema to use\" ) credentials : SnowflakeCredentials def _get_connect_params ( self ) -> Dict [ str , str ]: \"\"\" Creates a connect params mapping to pass into get_connection. \"\"\" connect_params = { \"database\" : self . database , \"warehouse\" : self . warehouse , \"schema\" : self . schema_ , # required to track task's usage in the Snowflake Partner Network Portal \"application\" : \"Prefect_Snowflake_Collection\" , ** self . credentials . dict (), } # filter out unset values connect_params = { param : value for param , value in connect_params . items () if value is not None } for param in ( \"password\" , \"private_key\" , \"token\" ): if param in connect_params : connect_params [ param ] = connect_params [ param ] . get_secret_value () # set authenticator to the actual okta_endpoint if connect_params . get ( \"authenticator\" ) == \"okta_endpoint\" : endpoint = connect_params . pop ( \"endpoint\" , None ) or connect_params . pop ( \"okta_endpoint\" , None ) # okta_endpoint is deprecated connect_params [ \"authenticator\" ] = endpoint private_der_key = self . credentials . resolve_private_key () if private_der_key is not None : connect_params [ \"private_key\" ] = private_der_key connect_params . pop ( \"password\" , None ) return connect_params def get_connection ( self ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector @flow def get_connection_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) print(snowflake_connector.get_connection()) get_connection_flow() ``` \"\"\" connect_params = self . _get_connect_params () connection = snowflake . connector . connect ( ** connect_params ) return connection","title":"SnowflakeConnector"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.schema_","text":"The name of the default schema to use","title":"schema_"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.warehouse","text":"The name of the default warehouse to use","title":"warehouse"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"database/#prefect_snowflake.database.SnowflakeConnector.get_connection","text":"Returns an authenticated connection that can be used to query from Snowflake databases. Returns: Type Description SnowflakeConnection The authenticated SnowflakeConnection. Examples: from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector @flow def get_connection_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) print ( snowflake_connector . get_connection ()) get_connection_flow () Source code in prefect_snowflake/database.py def get_connection ( self ) -> snowflake . connector . SnowflakeConnection : \"\"\" Returns an authenticated connection that can be used to query from Snowflake databases. Returns: The authenticated SnowflakeConnection. Examples: ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector @flow def get_connection_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) print(snowflake_connector.get_connection()) get_connection_flow() ``` \"\"\" connect_params = self . _get_connect_params () connection = snowflake . connector . connect ( ** connect_params ) return connection","title":"get_connection()"},{"location":"database/#prefect_snowflake.database.snowflake_multiquery","text":"Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Parameters: Name Type Description Default queries List[str] The list of queries to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> as_transaction bool If True, queries are executed in a transaction. False return_transaction_control_results bool Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. False poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[List[Tuple[Any]]] List of the outputs of response.fetchall() for each query. Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_multiquery @flow def snowflake_multiquery_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_multiquery ( [ \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , \"SELECT 1,2\" ], snowflake_connector , params = { \"id_param\" : 1 }, as_transaction = True ) return result snowflake_multiquery_flow () Source code in prefect_snowflake/database.py @task async def snowflake_multiquery ( queries : List [ str ], snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , as_transaction : bool = False , return_transaction_control_results : bool = False , poll_frequency_seconds : int = 1 , ) -> List [ List [ Tuple [ Any ]]]: \"\"\" Executes multiple queries against a Snowflake database in a shared session. Allows execution in a transaction. Args: queries: The list of queries to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. as_transaction: If True, queries are executed in a transaction. return_transaction_control_results: Determines if the results of queries controlling the transaction (BEGIN/COMMIT) should be returned. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: List of the outputs of `response.fetchall()` for each query. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_multiquery @flow def snowflake_multiquery_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_multiquery( [\"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", \"SELECT 1,2\"], snowflake_connector, params={\"id_param\": 1}, as_transaction=True ) return result snowflake_multiquery_flow() ``` \"\"\" with snowflake_connector . get_connection () as connection : if as_transaction : queries . insert ( 0 , BEGIN_TRANSACTION_STATEMENT ) queries . append ( END_TRANSACTION_STATEMENT ) with connection . cursor ( cursor_type ) as cursor : results = [] for query in queries : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () results . append ( result ) # cut off results from BEGIN/COMMIT queries if as_transaction and not return_transaction_control_results : return results [ 1 : - 1 ] else : return results","title":"snowflake_multiquery()"},{"location":"database/#prefect_snowflake.database.snowflake_query","text":"Executes a query against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> poll_frequency_seconds int Number of seconds to wait in between checks for run completion. 1 Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Query Snowflake table with the ID value parameterized. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query ( \"SELECT * FROM table WHERE id=% {id_param} s LIMIT 8;\" , snowflake_connector , params = { \"id_param\" : 1 } ) return result snowflake_query_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , poll_frequency_seconds : int = 1 , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. poll_frequency_seconds: Number of seconds to wait in between checks for run completion. Returns: The output of `response.fetchall()`. Examples: Query Snowflake table with the ID value parameterized. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query( \"SELECT * FROM table WHERE id=%{id_param}s LIMIT 8;\", snowflake_connector, params={\"id_param\": 1} ) return result snowflake_query_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : response = cursor . execute_async ( query , params = params ) query_id = response [ \"queryId\" ] while connection . is_still_running ( connection . get_query_status_throw_if_error ( query_id ) ): await asyncio . sleep ( poll_frequency_seconds ) cursor . get_results_from_sfqid ( query_id ) result = cursor . fetchall () return result","title":"snowflake_query()"},{"location":"database/#prefect_snowflake.database.snowflake_query_sync","text":"Executes a query in sync mode against a Snowflake database. Parameters: Name Type Description Default query str The query to execute against the database. required params Union[Tuple[Any], Dict[str, Any]] The params to replace the placeholders in the query. None snowflake_connector SnowflakeConnector The credentials to use to authenticate. required cursor_type SnowflakeCursor The type of database cursor to use for the query. <class 'snowflake.connector.cursor.SnowflakeCursor'> Returns: Type Description List[Tuple[Any]] The output of response.fetchall() . Examples: Execute a put statement. from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector , snowflake_query @flow def snowflake_query_sync_flow (): snowflake_credentials = SnowflakeCredentials ( account = \"account\" , user = \"user\" , password = \"password\" , ) snowflake_connector = SnowflakeConnector ( database = \"database\" , warehouse = \"warehouse\" , schema = \"schema\" , credentials = snowflake_credentials ) result = snowflake_query_sync ( \"put file://afile.csv @mystage;\" , snowflake_connector , ) return result snowflake_query_sync_flow () Source code in prefect_snowflake/database.py @task async def snowflake_query_sync ( query : str , snowflake_connector : SnowflakeConnector , params : Union [ Tuple [ Any ], Dict [ str , Any ]] = None , cursor_type : SnowflakeCursor = SnowflakeCursor , ) -> List [ Tuple [ Any ]]: \"\"\" Executes a query in sync mode against a Snowflake database. Args: query: The query to execute against the database. params: The params to replace the placeholders in the query. snowflake_connector: The credentials to use to authenticate. cursor_type: The type of database cursor to use for the query. Returns: The output of `response.fetchall()`. Examples: Execute a put statement. ```python from prefect import flow from prefect_snowflake.credentials import SnowflakeCredentials from prefect_snowflake.database import SnowflakeConnector, snowflake_query @flow def snowflake_query_sync_flow(): snowflake_credentials = SnowflakeCredentials( account=\"account\", user=\"user\", password=\"password\", ) snowflake_connector = SnowflakeConnector( database=\"database\", warehouse=\"warehouse\", schema=\"schema\", credentials=snowflake_credentials ) result = snowflake_query_sync( \"put file://afile.csv @mystage;\", snowflake_connector, ) return result snowflake_query_sync_flow() ``` \"\"\" # context manager automatically rolls back failed transactions and closes with snowflake_connector . get_connection () as connection : with connection . cursor ( cursor_type ) as cursor : cursor . execute ( query , params = params ) result = cursor . fetchall () return result","title":"snowflake_query_sync()"}]}